#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const os = require('os');
const { execSync } = require('child_process');

const homeDir = os.homedir();
const claudeSettingsPath = path.join(homeDir, '.claude', 'settings.json');
const zshutilPath = path.join(homeDir, 'zshutil');
const bashGuardPath = path.join(zshutilPath, 'bin', 'internal', 'claude-pretooluse-bash');

const expectedHook = {
  matcher: "Bash",
  hooks: [
    {
      type: "command",
      command: bashGuardPath
    }
  ]
};

function createBackup(filePath) {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const fileName = path.basename(filePath);
  const backupPath = path.join(os.tmpdir(), `${fileName}.backup.${timestamp}`);

  fs.copyFileSync(filePath, backupPath);
  console.log(`Created backup: ${backupPath}`);
  return backupPath;
}

function displayHookConfiguration(bashGuardPath, claudeSettingsPath) {
  console.log(`Hook command: ${bashGuardPath}`);
  console.log('\nCurrent configuration in ~/.claude/settings.json:');

  try {
    const jqOutput = execSync(
      `jq '.hooks.PreToolUse' "${claudeSettingsPath}"`,
      { encoding: 'utf8', shell: '/bin/bash' }
    );
    console.log(jqOutput);
  } catch (jqError) {
    console.log('(Unable to display hooks section with jq)');
  }
}

function main() {
  try {
    console.log(`Working with file: ${claudeSettingsPath}`);

    // Check if ~/.claude/settings.json exists
    if (!fs.existsSync(claudeSettingsPath)) {
      console.error('Error: ~/.claude/settings.json file not found');
      process.exit(1);
    }

    // Check if ~/zshutil/bin/internal/claude-pretooluse-bash exists
    if (!fs.existsSync(bashGuardPath)) {
      console.error('Error: ~/zshutil/bin/internal/claude-pretooluse-bash not found');
      process.exit(1);
    }

    // Create backup before making changes
    createBackup(claudeSettingsPath);

    // Read and parse the current settings.json
    const settingsContent = fs.readFileSync(claudeSettingsPath, 'utf8');
    let settings;

    try {
      settings = JSON.parse(settingsContent);
    } catch (parseError) {
      console.error('Error: Invalid JSON in ~/.claude/settings.json');
      process.exit(1);
    }

    // Initialize hooks object if it doesn't exist
    if (!settings.hooks) {
      settings.hooks = {};
    }

    // Initialize PreToolUse array if it doesn't exist
    if (!settings.hooks.PreToolUse) {
      settings.hooks.PreToolUse = [];
    }

    // Check if a Bash hook already exists
    const existingBashHookIndex = settings.hooks.PreToolUse.findIndex(
      hook => hook.matcher === "Bash"
    );

    if (existingBashHookIndex !== -1) {
      // Check if our Bash PreToolUse guard is already in the hooks
      const existingHooks = settings.hooks.PreToolUse[existingBashHookIndex].hooks || [];
      const alreadyInstalled = existingHooks.some(
        h => h.type === "command" && h.command === bashGuardPath
      );

      if (alreadyInstalled) {
        console.log('Bash PreToolUse guard hook is already installed in ~/.claude/settings.json');
        displayHookConfiguration(bashGuardPath, claudeSettingsPath);
        return;
      }

      // Add our hook to the existing Bash matcher
      existingHooks.push({
        type: "command",
        command: bashGuardPath
      });
      settings.hooks.PreToolUse[existingBashHookIndex].hooks = existingHooks;
      console.log('Added Bash PreToolUse guard to existing Bash hooks');
    } else {
      // No Bash hook exists, add our complete hook configuration
      settings.hooks.PreToolUse.push(expectedHook);
      console.log('Created new Bash hook with PreToolUse guard');
    }

    // Write the updated settings back to file with pretty formatting
    const updatedContent = JSON.stringify(settings, null, 2) + '\n';
    fs.writeFileSync(claudeSettingsPath, updatedContent);

    console.log('Successfully configured Bash PreToolUse guard hook in ~/.claude/settings.json');
    displayHookConfiguration(bashGuardPath, claudeSettingsPath);

  } catch (error) {
    console.error('Error:', error.message);
    process.exit(1);
  }
}

main();
